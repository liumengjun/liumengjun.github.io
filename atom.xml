<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple Space</title>
  
  <subtitle>这片世界是持有更高级文明的生命体创造的小宇宙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liumengjun.github.io/"/>
  <updated>2023-03-15T12:15:01.489Z</updated>
  <id>https://liumengjun.github.io/</id>
  
  <author>
    <name>Mengjun Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式数据计算引擎研习</title>
    <link href="https://liumengjun.github.io/2021/03/18/distributed-computation.html"/>
    <id>https://liumengjun.github.io/2021/03/18/distributed-computation.html</id>
    <published>2021-03-18T13:10:35.000Z</published>
    <updated>2023-03-15T12:15:01.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="distributed-computing-frameworks"><a href="#distributed-computing-frameworks" class="headerlink" title="distributed computing frameworks"></a>distributed computing frameworks</h2><p><code>spark, impala, bigquery, dask .etc</code></p><h2 id="Big-Concept"><a href="#Big-Concept" class="headerlink" title="Big Concept"></a>Big Concept</h2><h4 id="1-经典MapReduce"><a href="#1-经典MapReduce" class="headerlink" title="1, 经典MapReduce"></a>1, 经典<code>MapReduce</code></h4><p><img src="/images/distributed-computation/mapreduce-wordcount.png" alt="WordCount by MapReduce"><br><em>(Calculate Word Count by MapReduce)</em><br><a id="more"></a></p><p>MapReduce采用<code>“分而治之”</code>策略。MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数：Map和Reduce。一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的分片（split），这些分片可以被多个Map任务并行处理。通过Reduce最终把各个分片任务中间结果合并成一个结果。</p><h4 id="2-DAG-Directed-Acyclic-Graph-有向无环图"><a href="#2-DAG-Directed-Acyclic-Graph-有向无环图" class="headerlink" title="2, DAG(Directed Acyclic Graph)有向无环图"></a>2, <code>DAG(Directed Acyclic Graph)有向无环图</code></h4><p><img src="/images/distributed-computation/spark-dag.png" alt="Spark DAG"><br><em>(Spark DAG Demo)</em></p><p>RDD算子构建了RDD之间的关系，整个计算过程形成了一个由RDD和关系构成的DAG。点就是RDD（或者stage）, 线就是RDD算子（或者宽依赖算子）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们使用 spark-submit 提交的就是一个 application， 一个 application 可以有很多job。</span><br><span class="line">对 RDD 进行 action操作时，就会产生一个Job。</span><br><span class="line">每一个Job 又会根据 shuffle 操作，分为多个stage。</span><br><span class="line">一个stage会根据RDD的分区数，分为多个task。</span><br></pre></td></tr></table></figure><h4 id="3-MLST-Multi-Level-Service-Tree"><a href="#3-MLST-Multi-Level-Service-Tree" class="headerlink" title="3, MLST (Multi-Level Service Tree)"></a>3, <code>MLST (Multi-Level Service Tree)</code></h4><p><img src="/images/distributed-computation/dremel-service_tree-demo.png" alt="Dremel Service-Tree Demo"><br><em>(An example of Dremel Service-Tree)</em></p><p>根服务器收到此查询时，首先要做的是将查询转换为可以由下一级别的服务树处理的形式。它确定表T的所有分片，然后简化查询。<br>在这里，R11，R12，…R1n是发送到服务树的第1级的Mixer 1,…,n的查询结果。<br><code>R1i = SELECT A, COUNT(B) AS c FROM T1i GROUP BY A</code><br>下一步Mixer修改传入的查询，以便它们可以将其传递给Leaf节点。叶子节点接收自定义查询并从Colossus(数据存储层)分片读取数据。Lead节点读取查询中提到的列或字段的数据。当叶节点扫描分片时，它并行地浏览打开的列文件，一次一行。</p><h2 id="spark-vs-impala"><a href="#spark-vs-impala" class="headerlink" title="spark vs impala"></a>spark vs impala</h2><p>Impala查询器将所有内容缓存在内存中，而Spark将需要时间来提取此数据以执行查询计划。</p><p>shuffle实现方式, Spark在stage边界将临时文件写入磁盘，然而Impala尝试将所有内容保留在内存中。 Spark可以从丢失执行程序中恢复并通过重新计算丢失的块继续运行, Impala在单个impalad守护程序崩溃后将使整个查询失败。</p><p>工作分配机制不同 – Spark(DAG)将编译生成后的整个阶段代码发送给workers，Impala(MLST)只传递声明式查询片段。</p><p><del>“查询优化技术（查询矢量化，动态分区修剪，基于成本的优化）-平分秋色，提升点也差不多。”</del></p><h2 id="Dask-Example"><a href="#Dask-Example" class="headerlink" title="Dask Example"></a>Dask Example</h2><p><img src="/images/distributed-computation/dask_y0_y3_v2.png" alt="Dask Task Graph Example"><br><em>(Dask Task Graph Example)</em></p><p><code>积分方式计算ACBD区域面积</code><br><img src="/images/distributed-computation/area_ACBD.png" alt="积分方式计算ACBD区域面积"></p><blockquote><p><em><code>sum(y0(x) - y3(x) for x in x_range)</code></em></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">16</span></span><br><span class="line">delta_x = <span class="number">1</span> / n</span><br><span class="line">x_range = [i / n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y0</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""y0 = sqrt(1-x^2)"""</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">return</span> delta_x * math.sqrt(<span class="number">1</span> - x * x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y3</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""y3 = 1 - x"""</span></span><br><span class="line">    <span class="keyword">return</span> delta_x * (<span class="number">1</span> - x)</span><br><span class="line"></span><br><span class="line">a_quarter_circle_y = client.map(y0, x_range)</span><br><span class="line">a_triangle_y = client.map(y3, x_range)</span><br><span class="line">a_target_s = client.map(operator.sub, a_quarter_circle_y, a_triangle_y)</span><br><span class="line">a_target = client.submit(sum, a_target_s)</span><br><span class="line"><span class="comment"># a_target.result()</span></span><br><span class="line"><span class="comment"># 0.28081325945693536</span></span><br></pre></td></tr></table></figure><h2 id="dask-vs-spark"><a href="#dask-vs-spark" class="headerlink" title="dask vs spark"></a>dask vs spark</h2><p><strong>Spark和Dask都用有向无环图表示计算。但是这些图的粒度不同。</strong></p><p>在Spark RDD上执行的一项操作可能会将一个节点（例如Map和Filter）添加到图形中。这些是传达含义的高级操作，最终将变成许多要在单个工人上执行的小任务。这个小任务状态仅在Spark调度程序内部可用。（Spark stage 是一个物理执行单位。stage 是一组并行任务 - 每个分区一个任务。）</p><p>Dask跳过了这种高级表示，而直接进入了许多小任务阶段。这样，对Dask集合进行一次映射操作将立即生成并可能将数千个微小任务添加到Dask图中。</p><p>基础图规模的这种差异影响着可以进行的分析和优化的种类，也影响了用户暴露给用户的普遍性。 Dask无法执行Spark进行的某些优化，因为Dask调度程序没有自上而下执行的计算的图。但是，Dask能够轻松代表更复杂的算法，并将这些算法的创建向普通用户公开。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://data-flair.training/blogs/dag-in-apache-spark/" target="_blank" rel="noopener">https://data-flair.training/blogs/dag-in-apache-spark/</a></li><li><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf" target="_blank" rel="noopener">https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf</a></li><li><a href="https://panoply.io/data-warehouse-guide/bigquery-architecture/" target="_blank" rel="noopener">https://panoply.io/data-warehouse-guide/bigquery-architecture/</a></li><li><a href="https://docs.dask.org/en/latest/spark.html" target="_blank" rel="noopener">https://docs.dask.org/en/latest/spark.html</a></li><li><a href="https://www.jianshu.com/p/8c7e0f5ff326" target="_blank" rel="noopener">https://www.jianshu.com/p/8c7e0f5ff326</a></li><li><a href="https://waltyou.github.io/Spark-Tuning-Practice/" target="_blank" rel="noopener">https://waltyou.github.io/Spark-Tuning-Practice/</a></li><li><a href="https://waltyou.github.io/Mastering-Apache-Spark-Core-7-Services-DAGScheduler/" target="_blank" rel="noopener">https://waltyou.github.io/Mastering-Apache-Spark-Core-7-Services-DAGScheduler/</a></li><li><a href="https://stackoverflow.com/questions/58598727/impala-vs-spark-performance-for-ad-hoc-queries" target="_blank" rel="noopener">https://stackoverflow.com/questions/58598727/impala-vs-spark-performance-for-ad-hoc-queries</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;distributed-computing-frameworks&quot;&gt;&lt;a href=&quot;#distributed-computing-frameworks&quot; class=&quot;headerlink&quot; title=&quot;distributed computing frameworks&quot;&gt;&lt;/a&gt;distributed computing frameworks&lt;/h2&gt;&lt;p&gt;&lt;code&gt;spark, impala, bigquery, dask .etc&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Big-Concept&quot;&gt;&lt;a href=&quot;#Big-Concept&quot; class=&quot;headerlink&quot; title=&quot;Big Concept&quot;&gt;&lt;/a&gt;Big Concept&lt;/h2&gt;&lt;h4 id=&quot;1-经典MapReduce&quot;&gt;&lt;a href=&quot;#1-经典MapReduce&quot; class=&quot;headerlink&quot; title=&quot;1, 经典MapReduce&quot;&gt;&lt;/a&gt;1, 经典&lt;code&gt;MapReduce&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/distributed-computation/mapreduce-wordcount.png&quot; alt=&quot;WordCount by MapReduce&quot;&gt;&lt;br&gt;&lt;em&gt;(Calculate Word Count by MapReduce)&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://liumengjun.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="数据库" scheme="https://liumengjun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="大数据" scheme="https://liumengjun.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>漫谈数据存储发展</title>
    <link href="https://liumengjun.github.io/2021/01/26/data-store-trend.html"/>
    <id>https://liumengjun.github.io/2021/01/26/data-store-trend.html</id>
    <published>2021-01-26T13:31:17.000Z</published>
    <updated>2023-03-15T11:56:44.053Z</updated>
    
    <content type="html"><![CDATA[<p><code>用发展的眼光看问题（但是如何实践还是很难的）</code></p><h2 id="1-概览数据存储方式变化"><a href="#1-概览数据存储方式变化" class="headerlink" title="1. 概览数据存储方式变化"></a>1. 概览数据存储方式变化</h2><ul><li>文本文件(csv, xml, json)</li><li>二进制文件(*.dat, excel)(RCFile, Avro, parquet, orc)</li><li>sql rdb</li><li>no sql</li><li>redis &lt;key, value&gt;</li><li>mongo (partition, shard)</li><li>big table {HBase} （row, column family, time）, slice, tablet</li><li>es  (cluster 、 node 、 shard{ Lucene })</li><li>图数据库 {Neo4J} (node - relation)</li><li>OceanBase？</li><li>TiDB，CockroachDB</li></ul><h3 id="1-1-RDBMS-vs-NoSQL"><a href="#1-1-RDBMS-vs-NoSQL" class="headerlink" title="1.1 RDBMS vs NoSQL"></a>1.1 RDBMS vs NoSQL</h3><a id="more"></a><h4 id="1-1-1-RDBMS"><a href="#1-1-1-RDBMS" class="headerlink" title="1.1.1 RDBMS"></a>1.1.1 RDBMS</h4><p>RDBMS特点</p><ul><li>高度组织化结构化数据</li><li>结构化查询语言（SQL） (SQL)</li><li>数据和关系都存储在单独的表中。</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务ACID</li></ul><p>过一下RDBMS有哪些</p><ul><li>ms access db</li><li>FoxPro</li><li>SQL Server</li><li>DB2</li><li>Oracle</li><li>MySQL (MariaDB, Percona)</li><li>PostgreSQL</li><li>sqlite3</li><li>H2</li><li>hsqldb</li></ul><h4 id="1-1-2-NoSQL-Not-Only"><a href="#1-1-2-NoSQL-Not-Only" class="headerlink" title="1.1.2 NoSQL(Not Only)"></a>1.1.2 NoSQL(Not Only)</h4><p>NoSQL特点</p><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>高性能，高可用性和可伸缩性</li></ul><h4 id="NoSQL-数据库分类"><a href="#NoSQL-数据库分类" class="headerlink" title="NoSQL 数据库分类"></a>NoSQL 数据库分类</h4><table><thead><tr><th>类型</th><th>部分代表</th><th>特点</th></tr></thead><tbody><tr><td>列存储</td><td>Hbase，Cassandra，Hypertable，ClickHouse</td><td>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td></tr><tr><td>文档存储</td><td>MongoDB，CouchDB</td><td>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。</td></tr><tr><td>key-value存储</td><td>Tokyo Cabinet / Tyrant，Berkeley DB，MemcacheDB，Redis</td><td>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</td></tr><tr><td>图存储</td><td>Neo4J，FlockDB</td><td>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</td></tr><tr><td>对象存储</td><td>db4o，Versant</td><td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td></tr><tr><td>xml数据库</td><td>Berkeley DB XML，BaseX</td><td>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</td></tr></tbody></table><h4 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点/缺点"></a>NoSQL的优点/缺点</h4><p>优点:</p><ul><li>高可扩展性</li><li>分布式计算</li><li>低成本</li><li>架构的灵活性，半结构化数据</li><li>没有复杂的关系</li></ul><p>缺点:</p><ul><li>没有标准化</li><li>有限的查询功能（到目前为止）</li><li>最终一致是不直观的程序</li></ul><h3 id="1-2-NewSQL"><a href="#1-2-NewSQL" class="headerlink" title="1.2 NewSQL"></a>1.2 NewSQL</h3><p>NewSQL 是一种新方式关系数据库，意在整合 RDBMS 所提供的ACID事务特性（即原子性、一致性、隔离性和可持久性），以及 NoSQL 提供的横向可扩展性。</p><p>比如，MyRocks，TiDB，参考F1/Spanner。</p><p>(了解不多，请大家一起研究)</p><h2 id="2-数据如何存储的"><a href="#2-数据如何存储的" class="headerlink" title="2. 数据如何存储的"></a>2. 数据如何存储的</h2><h3 id="2-1-行模式-vs-列模式"><a href="#2-1-行模式-vs-列模式" class="headerlink" title="2.1 行模式 vs 列模式"></a>2.1 行模式 vs 列模式</h3><p><img src="/images/data-store-trend/row-column-store.jpeg" alt="[row-column-store.jpeg|row-column-store.jpeg]"></p><h3 id="2-2-存储引擎（MySQL发扬的概念）以及索引组织方式"><a href="#2-2-存储引擎（MySQL发扬的概念）以及索引组织方式" class="headerlink" title="2.2 存储引擎（MySQL发扬的概念）以及索引组织方式"></a>2.2 存储引擎（MySQL发扬的概念）以及索引组织方式</h3><p>Memory</p><p>MyISAM(My索引顺序存取方法)(最初是IBM公司发展起来的一个文件系统)</p><p>InnoDB</p><p>Merge</p><p>tokuDB</p><p>MyRocks</p><h4 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h4><p>Hash</p><p>RTree</p><p>Fractal树(分形树)</p><p>B+Tree</p><p>Log Structured Merge Trees(LSM) {MemTable, SSTable(Sorted String Table)} (From BigTable)</p><p>@B+Tree结构图</p><p><img src="/images/data-store-trend/B_Tree_Structure.png" alt="[B_Tree_Structure.png|B_Tree_Structure.png]"></p><p>@LSM Tree 结构图</p><p><img src="/images/data-store-trend/LSM-Tree.jpeg" alt="[LSM-Tree.jpeg|LSM-Tree.jpeg]"></p><h3 id="2-2-分布式"><a href="#2-2-分布式" class="headerlink" title="2.2 分布式"></a>2.2 分布式</h3><p>读写分类</p><p><img src="/images/data-store-trend/read-write-separate.png" alt="[read-write-separate.png|read-write-separate.png]"></p><p>mongo分片集合</p><p><img src="/images/data-store-trend/mongo-sharded-collection.png" alt="[mongo-sharded-collection.png|mongo-sharded-collection.png]"></p><p>elastic节点分区和复制（elastic_nodes_0204）</p><p><img src="/images/data-store-trend/elastic_nodes_0204.png" alt="[elastic_nodes_0204.png|elastic_nodes_0204.png]"></p><h4 id="CAP定理（CAP-theorem）"><a href="#CAP定理（CAP-theorem）" class="headerlink" title="CAP定理（CAP theorem）"></a>CAP定理（CAP theorem）</h4><p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p><ul><li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li><li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li><li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ul><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><h4 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h4><ul><li>Paxos算法: 各副本竞争提议权，然后让议案在各副本间达成一致</li><li>Raft算法: 先选举出leader，leader完全负责replicated log的管理。</li><li>一致性hash算法(归位分布式算法有些牵强): 以前点映射改为区段映射，使得数据节点变更后其他数据节点变动尽可能小</li><li>EPaxos（Egalitarian Paxos）</li></ul><p>NOTE: 分布式部署一般不保证事务，这是NEWSQL要挑战的难点。Google的Spanner/F1提出了一种TrueTime API，使得事务序列化满足外部一致性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://www.cnblogs.com/hdc520/p/13718470.html" target="_blank" rel="noopener">https://www.cnblogs.com/hdc520/p/13718470.html</a></p><p><a href="https://www.runoob.com/mongodb/nosql.html" target="_blank" rel="noopener">https://www.runoob.com/mongodb/nosql.html</a></p><p><a href="http://dblab.xmu.edu.cn/post/google-bigtable/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/post/google-bigtable/</a></p><p><a href="https://cloud.tencent.com/developer/article/1131036" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1131036</a></p><p><a href="https://segmentfault.com/a/1190000009707788" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009707788</a></p><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf</a></p><p><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf</a></p><p><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41344.pdf" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41344.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;用发展的眼光看问题（但是如何实践还是很难的）&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-概览数据存储方式变化&quot;&gt;&lt;a href=&quot;#1-概览数据存储方式变化&quot; class=&quot;headerlink&quot; title=&quot;1. 概览数据存储方式变化&quot;&gt;&lt;/a&gt;1. 概览数据存储方式变化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文本文件(csv, xml, json)&lt;/li&gt;
&lt;li&gt;二进制文件(*.dat, excel)(RCFile, Avro, parquet, orc)&lt;/li&gt;
&lt;li&gt;sql rdb&lt;/li&gt;
&lt;li&gt;no sql&lt;/li&gt;
&lt;li&gt;redis &amp;lt;key, value&amp;gt;&lt;/li&gt;
&lt;li&gt;mongo (partition, shard)&lt;/li&gt;
&lt;li&gt;big table {HBase} （row, column family, time）, slice, tablet&lt;/li&gt;
&lt;li&gt;es  (cluster 、 node 、 shard{ Lucene })&lt;/li&gt;
&lt;li&gt;图数据库 {Neo4J} (node - relation)&lt;/li&gt;
&lt;li&gt;OceanBase？&lt;/li&gt;
&lt;li&gt;TiDB，CockroachDB&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-RDBMS-vs-NoSQL&quot;&gt;&lt;a href=&quot;#1-1-RDBMS-vs-NoSQL&quot; class=&quot;headerlink&quot; title=&quot;1.1 RDBMS vs NoSQL&quot;&gt;&lt;/a&gt;1.1 RDBMS vs NoSQL&lt;/h3&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://liumengjun.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="数据库" scheme="https://liumengjun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="大数据" scheme="https://liumengjun.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Kafka入门</title>
    <link href="https://liumengjun.github.io/2021/01/25/kafka-intro.html"/>
    <id>https://liumengjun.github.io/2021/01/25/kafka-intro.html</id>
    <published>2021-01-25T14:53:43.000Z</published>
    <updated>2023-03-15T10:06:38.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-sites"><a href="#web-sites" class="headerlink" title="web sites"></a>web sites</h2><ul><li><strong>home</strong>: <a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></li><li><strong>wiki</strong>: <a href="https://cwiki.apache.org/confluence/display/KAFKA/Index" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Index</a></li><li><strong>生态</strong>: <a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem</a></li></ul><h2 id="wikipedia-介绍"><a href="#wikipedia-介绍" class="headerlink" title="wikipedia 介绍"></a>wikipedia 介绍</h2><p><code>Kafka from领英，2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。2014年11月，几个曾在领英为Kafka工作的工程师，创建了confluent.io新公司。根据2014年Quora的帖子，Jay Kreps似乎已经将它以作家弗朗茨·卡夫卡命名，它是“一个用于优化写作的系统”。</code></p><h2 id="different-with-MessageQueue"><a href="#different-with-MessageQueue" class="headerlink" title="different with MessageQueue"></a>different with MessageQueue</h2><ul><li>common mq: RabbitMQ, Redis, ActiveMQ, zeroMQ, rocketMQ，数据库？应用服务器间消息传递</li><li>kafka: 主要用于处理活跃的流式数据,大数据量的数据处理上.</li></ul><a id="more"></a><h2 id="get-started"><a href="#get-started" class="headerlink" title="get started"></a>get started</h2><ol><li><p>下载安装, 可以配置KAFKA_HOME和PATH</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HOME=<span class="string">"/data/tools/kafka"</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$KAFKA_HOME</span>/bin"</span></span><br></pre></td></tr></table></figure></li><li><p>单机配置: 另选zookeeper port, 一些工作目录 /tmp/ -&gt; 正常目录(注意磁盘和内存大小？daily-disk-clean.sh)</p></li></ol><ul><li><p>zookeeper config(<code>zookeeper.properties</code>)</p>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataDir</span>=/data/appdata/kafka/zookeeper</span><br><span class="line"><span class="attr">clientPort</span>=<span class="number">32181</span></span><br></pre></td></tr></table></figure></li><li><p>kafka server config(<code>server.properties</code>)</p>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper.connect</span>=localhost:<span class="number">32181</span></span><br><span class="line"><span class="attr">log.dirs</span>=/data/appdata/kafka/kafka-logs</span><br><span class="line"><span class="attr">log.retention.hours</span>=<span class="number">90</span></span><br><span class="line"><span class="attr">log.retention.bytes</span>=<span class="number">61073741824</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>启动 zookeeper &amp; kafka，包装启动脚本，放到<code>$HOME/bin</code></li></ol><ul><li><p><code>kafka_zk_start</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$KAFKA_HOME</span></span><br><span class="line">nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure></li><li><p><code>kafka_server_start</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$KAFKA_HOME</span></span><br><span class="line">nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>创建topic</li></ol><ul><li><p>create</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create</span></span><br><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>list</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure><p><code>--bootstrap-server</code> 指定kafka server，也可用<code>--zookeeper</code></p></li></ul><ol start="5"><li><p>启动producer发送信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>不创建topic，直接指定topic发消息，也会自动创建。<code>advoracle/cli/tool/userlog2kafka.py</code></p></li><li><p>启动consumer接收消息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><ul><li>可以看到正在发送的消息，也可看到之前发送的消息</li><li>去掉<code>--from-beginning</code>, 只能看到正在发送的消息</li></ul></li></ol><h2 id="Kafka-Web-Manager"><a href="#Kafka-Web-Manager" class="headerlink" title="Kafka Web Manager"></a>Kafka Web Manager</h2><p><a href="https://github.com/yahoo/CMAK" target="_blank" rel="noopener">https://github.com/yahoo/CMAK</a></p><p>scala项目, 效果: <a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000/</a></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><code>详见: https://cwiki.apache.org/confluence/display/KAFKA/Clients</code></p><ul><li>python: <a href="https://github.com/confluentinc/confluent-kafka-python" target="_blank" rel="noopener">confluent-kafka</a></li></ul><h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><ol><li>集群部署</li><li>Connect组件导入导出迁移数据</li><li>Kafka Stream, 致力于流式计算框架，like flink。所以还有个产品叫ksqlDB</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;web-sites&quot;&gt;&lt;a href=&quot;#web-sites&quot; class=&quot;headerlink&quot; title=&quot;web sites&quot;&gt;&lt;/a&gt;web sites&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;home&lt;/strong&gt;: &lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://kafka.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wiki&lt;/strong&gt;: &lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cwiki.apache.org/confluence/display/KAFKA/Index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态&lt;/strong&gt;: &lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;wikipedia-介绍&quot;&gt;&lt;a href=&quot;#wikipedia-介绍&quot; class=&quot;headerlink&quot; title=&quot;wikipedia 介绍&quot;&gt;&lt;/a&gt;wikipedia 介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Kafka from领英，2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。2014年11月，几个曾在领英为Kafka工作的工程师，创建了confluent.io新公司。根据2014年Quora的帖子，Jay Kreps似乎已经将它以作家弗朗茨·卡夫卡命名，它是“一个用于优化写作的系统”。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;different-with-MessageQueue&quot;&gt;&lt;a href=&quot;#different-with-MessageQueue&quot; class=&quot;headerlink&quot; title=&quot;different with MessageQueue&quot;&gt;&lt;/a&gt;different with MessageQueue&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;common mq: RabbitMQ, Redis, ActiveMQ, zeroMQ, rocketMQ，数据库？应用服务器间消息传递&lt;/li&gt;
&lt;li&gt;kafka: 主要用于处理活跃的流式数据,大数据量的数据处理上.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据流处理" scheme="https://liumengjun.github.io/categories/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86/"/>
    
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
      <category term="消息队列" scheme="https://liumengjun.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="数据流处理" scheme="https://liumengjun.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JPA query 的几种写法</title>
    <link href="https://liumengjun.github.io/2019/05/08/jpa-query-demos.html"/>
    <id>https://liumengjun.github.io/2019/05/08/jpa-query-demos.html</id>
    <published>2019-05-08T13:57:32.000Z</published>
    <updated>2023-03-15T09:29:23.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-jpql"><a href="#1-jpql" class="headerlink" title="1. jpql"></a>1. jpql</h2><p><code>JPQL is hql? jpa 是javaee的一部分规范，spring data jpa 采用hibernate实现，eclipse也有实现JPA，等等https://zh.wikipedia.org/wiki/Java%E6%8C%81%E4%B9%85%E5%8C%96APIhttps://jcp.org/aboutJava/communityprocess/final/jsr338/index.html</code></p><h3 id="interfaces-命名"><a href="#interfaces-命名" class="headerlink" title="interfaces 命名"></a>interfaces 命名</h3><ul><li>findXxx</li><li>findBy</li><li>count</li><li>page</li></ul><h3 id="注解中写法-query-nativeQuery-false"><a href="#注解中写法-query-nativeQuery-false" class="headerlink" title="注解中写法 @query (nativeQuery=false)"></a>注解中写法 @query (nativeQuery=false)</h3><ul><li>select * from Entity</li><li>select e from Entity e</li><li>select e.* from Entity e</li><li>from Entity</li><li>select col1, col2, col3 from Entity // List&lt;Object[]&gt;</li><li>select new ai.advance.your.package.Pojo(col1, col2, col3) from Entity</li><li>select new map(… // 这种方式很傻，key为”0”,”1”.etc（??col as keyName）</li></ul><h3 id="构造criteria-query"><a href="#构造criteria-query" class="headerlink" title="构造criteria query"></a>构造criteria query</h3><a id="more"></a><p><code>@query (nativeQuery=false)是静态的，criteria可以用程序动态组装查询语句</code></p><ul><li><p>criteria: CriteriaBuilder + CriteriaQuery + Expression + Predicate =&gt; TypedQuery</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Root&lt;?&gt; root = query.from(Entity.class);</span><br><span class="line">query.where(<span class="keyword">this</span>.buildPredicates(root, builder, params...));</span><br><span class="line"><span class="keyword">return</span> lem.createQuery(query).getResultList();</span><br></pre></td></tr></table></figure></li><li><p>Specification 类似</p></li><li>Example 很懒</li><li>Join 比较复杂, 需要定义Entity时就指明关联关系</li></ul><h3 id="result-type"><a href="#result-type" class="headerlink" title="result type"></a>result type</h3><ul><li>select(root)</li><li>Pojo(field1, field2) + Root<entity>, builder.createQuery(Pojo.class) + multiselect(field1, field2)<br><code>Root仍然是Entity，用于组装Selection，Pojo为结果类型</code></entity></li><li>builder.construct(Pojo.class, field1, field2) 同上</li><li>Tuple 作为结果类型</li><li>没有Pojo类，结果为Object[]</li></ul><h2 id="2-native-sql"><a href="#2-native-sql" class="headerlink" title="2. native sql"></a>2. native sql</h2><h3 id="query-nativeQuery-true"><a href="#query-nativeQuery-true" class="headerlink" title="@query (nativeQuery=true)"></a>@query (nativeQuery=true)</h3><ul><li>普通的sql，大家好像偏爱这种方式</li><li>方便join语句</li><li>方便各种聚合查询</li></ul><h3 id="createNativeQuery"><a href="#createNativeQuery" class="headerlink" title="createNativeQuery"></a>createNativeQuery</h3><p><code>带参数时要防止sql注入</code></p><ul><li>程序组装sql，更灵活的方式写sql</li><li><p>注意模糊查询参数设置</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql += <span class="string">"col like :key"</span>;</span><br><span class="line">...</span><br><span class="line">query.setParameter(key, <span class="string">"%"</span> + value + <span class="string">"%"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="结果类型和result-transformer"><a href="#结果类型和result-transformer" class="headerlink" title="结果类型和result transformer"></a>结果类型和<code>result transformer</code></h3><p><code>native query时可显示指定结果类型固定（即使select个别字段）,有时可以借助ResultTransformer以返回更多样的结果类型</code></p><ul><li>Object[]<br><code>no resultType no transformer</code></li><li>Map&lt;String, Object&gt;<br><code>map transformer</code></li><li>Pojo<ul><li>createNativeQuery(Pojo.class)</li><li>Transformers.aliasToBean(Pojo.class). sql中下划线col需要显示指定别名和Pojo中field名称相同</li></ul></li><li>List，Transformers.TO_LIST, bad idea</li></ul><p><strong><em> result transformer 例子 </em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select col1, col2, col3 from t_entity"</span>;</span><br><span class="line">Query query = em.createNativeQuery(sql); <span class="comment">// no resultClass</span></span><br><span class="line"><span class="comment">// Query 接口是 spring-data-jpa 的接口，而 org.hibernate.SQLQuery 接口是 hibenate 的接口，这里的做法就是先转成 hibenate 的查询接口对象，然后设置结果转换器</span></span><br><span class="line">query.unwrap(org.hibernate.SQLQuery.class).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);</span><br><span class="line"><span class="keyword">return</span> query.getResultList(); <span class="comment">// List&lt;Map&lt;String, Object&gt;&gt;, key为列名，含有下划线</span></span><br></pre></td></tr></table></figure><p><code></code><br>criteria 风格的 TypedQuery 生成的sql语句alias是col_m_n_之类的，不适用ALIAS_TO_ENTITY_MAP，aliasToBean。</p><p>query.unwrap 参数为org.hibernate.SQLQuery，而不是org.hibernate.Query。TypedQuery不能unwrap为org.hibernate.SQLQuery，即使unwrap成org.hibernate.Query，也得不到任何结果。</p><p><code>ResultTransformer</code>接口<br><code></code></p><h2 id="3-分页"><a href="#3-分页" class="headerlink" title="3. 分页"></a>3. 分页</h2><ul><li>老老实实limit offset, size</li><li>JPA page小优化: 如果返回条数n小于size，就可以推测总条数为offset+n，否则，还需要再查询一次总条数</li><li>确定数据量小，比如&lt;1000，可以选择在应用服务器里分页，甚至都丢给web端让web端分页</li><li>数据量特大，where id &gt; last_page_max_id limit size，这样可以不管总条数是多少，如果where查询恰好为索引，总条数计算快，否则慢的不可想象</li></ul><h2 id="n-原则"><a href="#n-原则" class="headerlink" title="n. 原则"></a>n. 原则</h2><ul><li>具体类型对宽泛的类型更好</li><li>使用索引</li><li>select 必要的字段</li><li>大量数据时分批</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-jpql&quot;&gt;&lt;a href=&quot;#1-jpql&quot; class=&quot;headerlink&quot; title=&quot;1. jpql&quot;&gt;&lt;/a&gt;1. jpql&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JPQL is hql? jpa 是javaee的一部分规范，spring data jpa 采用hibernate实现，eclipse也有实现JPA，等等
https://zh.wikipedia.org/wiki/Java%E6%8C%81%E4%B9%85%E5%8C%96API
https://jcp.org/aboutJava/communityprocess/final/jsr338/index.html&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;interfaces-命名&quot;&gt;&lt;a href=&quot;#interfaces-命名&quot; class=&quot;headerlink&quot; title=&quot;interfaces 命名&quot;&gt;&lt;/a&gt;interfaces 命名&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;findXxx&lt;/li&gt;
&lt;li&gt;findBy&lt;/li&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;page&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;注解中写法-query-nativeQuery-false&quot;&gt;&lt;a href=&quot;#注解中写法-query-nativeQuery-false&quot; class=&quot;headerlink&quot; title=&quot;注解中写法 @query (nativeQuery=false)&quot;&gt;&lt;/a&gt;注解中写法 @query (nativeQuery=false)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;select * from Entity&lt;/li&gt;
&lt;li&gt;select e from Entity e&lt;/li&gt;
&lt;li&gt;select e.* from Entity e&lt;/li&gt;
&lt;li&gt;from Entity&lt;/li&gt;
&lt;li&gt;select col1, col2, col3 from Entity // List&amp;lt;Object[]&amp;gt;&lt;/li&gt;
&lt;li&gt;select new ai.advance.your.package.Pojo(col1, col2, col3) from Entity&lt;/li&gt;
&lt;li&gt;select new map(… // 这种方式很傻，key为”0”,”1”.etc（??col as keyName）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;构造criteria-query&quot;&gt;&lt;a href=&quot;#构造criteria-query&quot; class=&quot;headerlink&quot; title=&quot;构造criteria query&quot;&gt;&lt;/a&gt;构造criteria query&lt;/h3&gt;
    
    </summary>
    
      <category term="服务端" scheme="https://liumengjun.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
      <category term="jpa" scheme="https://liumengjun.github.io/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>java11 var 关键字和 cli 方式执行</title>
    <link href="https://liumengjun.github.io/2019/03/29/java11-var-shebang-feature.html"/>
    <id>https://liumengjun.github.io/2019/03/29/java11-var-shebang-feature.html</id>
    <published>2019-03-29T13:47:06.000Z</published>
    <updated>2019-04-05T14:34:21.249Z</updated>
    
    <content type="html"><![CDATA[<p>java11 在语法上支持动态类型推断，还支持在命令行运行源码。其实<code>var</code>关键字在java10已经支持了，而且从java9开始就添加了<code>jshell</code>命令等，不过9和10都已经夭折了，而且现在java11都更新过一个版本了，我们大大方方的讨论java11吧。</p><p><strong>动态类型推断</strong>，这个术语可能不严谨，<code>openjdk</code>网站上描述是<code>Local-Variable Type Inference</code>(本地变量类型推断)，参考 <a href="http://openjdk.java.net/jeps/286" target="_blank" rel="noopener">JEP 286</a>。</p><p><strong>在命令行运行源码</strong>，不是指<code>jshell</code>，而是<code>Launch Single-File Source-Code Programs</code>(启动单个源码程序)，<code>java</code>命令直接启动源码文件，还有<code>shebang</code>特性，参考 <a href="http://openjdk.java.net/jeps/330" target="_blank" rel="noopener">JEP 330</a>。</p><h3 id="看个简单例子：创建Hello-java文件，内容如下"><a href="#看个简单例子：创建Hello-java文件，内容如下" class="headerlink" title="看个简单例子：创建Hello.java文件，内容如下"></a>看个简单例子：创建<code>Hello.java</code>文件，内容如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">var</span> hi = <span class="string">"hello world"</span>;</span><br><span class="line">        <span class="keyword">var</span> bool = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">        list.add(hi);</span><br><span class="line">        list.add(bool);</span><br><span class="line">        list.add(i+i);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到代码中使用了<code>var</code>关键字，即使用了<strong>动态类型推断</strong>特性。<br>然后，<strong>在命令行中执行</strong><code>java Hello.java</code>命令，输出<code>[hello world, true, 2]</code>。<br><a id="more"></a></p><p>注意：如果你的系统中安装了多个<code>java</code>版本，请确保<code>java11</code>为当前默认的java版本。比如，也安装了<code>java8</code>，而且平时默认是<code>java8</code>，需要临时改一下：在命令行中设置<code>JAVA_HOME</code>为<code>jdk11</code>的安装目录，然后把新<code>JAVA_HOME</code>/bin路径放到当前<code>PATH</code>的环境变量的最前面，这样就可以了。</p><h3 id="下面看一看Shebang特性："><a href="#下面看一看Shebang特性：" class="headerlink" title="下面看一看Shebang特性："></a>下面看一看<code>Shebang</code>特性：</h3><p>把Hello.java复制一份为Hello，<code>cp Hello.java Hello</code>，然后在Hello的文件头添加一行内容<br><code>#!/usr/bin/java --source 11</code><br>(注意，不要直接修改Hello.java文件)。此时文件内容形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/java --source 11</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        var list = new ArrayList&lt;&gt;();</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>把Hello设置为可执行文件<code>chmod +x Hello</code>，然后执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Hello</span><br></pre></td></tr></table></figure></p><p>可以看到命令正常运行，输出<code>[hello world, true, 2]</code>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://openjdk.java.net/jeps/286" target="_blank" rel="noopener">http://openjdk.java.net/jeps/286</a></li><li><a href="http://openjdk.java.net/jeps/330" target="_blank" rel="noopener">http://openjdk.java.net/jeps/330</a></li><li><a href="https://stackoverflow.com/questions/52530470/java-11-executing-source-file-via-shebang-is-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/52530470/java-11-executing-source-file-via-shebang-is-not-working</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java11 在语法上支持动态类型推断，还支持在命令行运行源码。其实&lt;code&gt;var&lt;/code&gt;关键字在java10已经支持了，而且从java9开始就添加了&lt;code&gt;jshell&lt;/code&gt;命令等，不过9和10都已经夭折了，而且现在java11都更新过一个版本了，我们大大方方的讨论java11吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态类型推断&lt;/strong&gt;，这个术语可能不严谨，&lt;code&gt;openjdk&lt;/code&gt;网站上描述是&lt;code&gt;Local-Variable Type Inference&lt;/code&gt;(本地变量类型推断)，参考 &lt;a href=&quot;http://openjdk.java.net/jeps/286&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JEP 286&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在命令行运行源码&lt;/strong&gt;，不是指&lt;code&gt;jshell&lt;/code&gt;，而是&lt;code&gt;Launch Single-File Source-Code Programs&lt;/code&gt;(启动单个源码程序)，&lt;code&gt;java&lt;/code&gt;命令直接启动源码文件，还有&lt;code&gt;shebang&lt;/code&gt;特性，参考 &lt;a href=&quot;http://openjdk.java.net/jeps/330&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JEP 330&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;看个简单例子：创建Hello-java文件，内容如下&quot;&gt;&lt;a href=&quot;#看个简单例子：创建Hello-java文件，内容如下&quot; class=&quot;headerlink&quot; title=&quot;看个简单例子：创建Hello.java文件，内容如下&quot;&gt;&lt;/a&gt;看个简单例子：创建&lt;code&gt;Hello.java&lt;/code&gt;文件，内容如下&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.ArrayList;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Hello&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; hi = &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bool = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(hi);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(bool);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(i+i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到代码中使用了&lt;code&gt;var&lt;/code&gt;关键字，即使用了&lt;strong&gt;动态类型推断&lt;/strong&gt;特性。&lt;br&gt;然后，&lt;strong&gt;在命令行中执行&lt;/strong&gt;&lt;code&gt;java Hello.java&lt;/code&gt;命令，输出&lt;code&gt;[hello world, true, 2]&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="程序语言" scheme="https://liumengjun.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>构建 puppeteer docker 镜像</title>
    <link href="https://liumengjun.github.io/2019/03/16/node-puppeteer-docker.html"/>
    <id>https://liumengjun.github.io/2019/03/16/node-puppeteer-docker.html</id>
    <published>2019-03-16T12:17:00.000Z</published>
    <updated>2019-04-05T02:17:09.798Z</updated>
    
    <content type="html"><![CDATA[<!-- # Puppeteer docker --><p>有时候需要在服务端生成PDF，可是在服务端生成的PDF不如浏览器中看到的页面美观，就想到了浏览器<code>headless</code>模式，在服务端访问前端，然后以PDF格式打印网页。<br>前端大神安利了<code>puppeteer</code>，确实很不错，还支持定制页眉页脚。<br>再者服务端程序是使用<code>docker</code>管理的，所以需要创建含有<code>puppeteer</code>的<code>docker</code>镜像。</p><h2 id="先看Dockerfile"><a href="#先看Dockerfile" class="headerlink" title="先看Dockerfile"></a>先看Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于`alpine`版本的`node`10</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.15</span>.<span class="number">2</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Chromium (72)。从 alpine/v3.9 版本库中下载</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> @v3.9 http://dl-cdn.alpinelinux.org/alpine/v3.9/community &gt;&gt; /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> @v3.9 http://dl-cdn.alpinelinux.org/alpine/v3.9/main &gt;&gt; /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache \</span></span><br><span class="line"><span class="bash">      freetype@v3.9 \</span></span><br><span class="line"><span class="bash">      chromium@v3.9 \</span></span><br><span class="line"><span class="bash">      harfbuzz@v3.9 \</span></span><br><span class="line"><span class="bash">      nss@v3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Puppeteer 时不让它自动下载 Chromium</span></span><br><span class="line"><span class="keyword">ENV</span> PUPPETEER_SKIP_CHROMIUM_DOWNLOAD true</span><br><span class="line"><span class="comment"># 选择 Chromium 72 对应的 Puppeteer 版本</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn add puppeteer@1.11.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S pptruser &amp;&amp; adduser -S -g pptruser pptruser \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /home/pptruser/Downloads \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chown -R pptruser:pptruser /home/pptruser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 cjk 字体以支持中文</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> NotoSansCJK-Regular.ttc  /usr/share/fonts/TTF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> pptruser</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Dockerfile部分说明"><a href="#Dockerfile部分说明" class="headerlink" title="Dockerfile部分说明"></a>Dockerfile部分说明</h3><ul><li>选择<code>alpine</code>版，是因为已有<code>alpine</code>版的<code>java</code>镜像。其实<code>docker</code>不支持合并镜像，还需要基于原<code>java</code>镜像再安装<code>Puppeteer</code>组成新的镜像</li><li>没有选择<code>edge</code>版仓库, <code>edge</code>是在开发中的, 有不确定性</li><li>已有<code>java</code>镜像<code>alpine</code>版本是v3.7, 有些工具包和此次版本不兼容，需要安装v3.9的<code>freetype</code>等</li><li>字体选择<a href="https://www.google.com/get/noto/" target="_blank" rel="noopener">开源字体</a>，防止被告</li></ul><h2 id="构建-docker-image"><a href="#构建-docker-image" class="headerlink" title="构建 docker image"></a>构建 docker image</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t node-puppeteer:puppeteer1_11-node10-alpine .</span><br></pre></td></tr></table></figure><p><a href="https://hub.docker.com/r/zhonglijunyi/node-puppeteer" target="_blank" rel="noopener">下载该镜像</a></p><h2 id="执行example"><a href="#执行example" class="headerlink" title="执行example"></a>执行example</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当你执行时，最好使用`--volume`选项，方便取出后面生成的文件</span></span><br><span class="line">docker run -it --rm node-puppeteer:puppeteer1_11-node10-alpine sh</span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">vi example.js <span class="comment"># 内容如下</span></span><br><span class="line">node example.js <span class="comment"># 得到 example.png</span></span><br></pre></td></tr></table></figure><p>example.js文件内容（此处以生成图片快照为例，若要生成PDF，请参考puppeteer文档）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    executablePath: <span class="string">'/usr/bin/chromium-browser'</span>,</span><br><span class="line">    args: [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-setuid-sandbox'</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/issues/1825" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer/issues/1825</a></li><li><a href="https://www.google.com/get/noto/" target="_blank" rel="noopener">https://www.google.com/get/noto/</a> 开源字体</li><li><a href="https://gitee.com/liumengjun/config-files/tree/master/nodejs/puppeteer-docker" target="_blank" rel="noopener">https://gitee.com/liumengjun/config-files/tree/master/nodejs/puppeteer-docker</a> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- # Puppeteer docker --&gt;
&lt;p&gt;有时候需要在服务端生成PDF，可是在服务端生成的PDF不如浏览器中看到的页面美观，就想到了浏览器&lt;code&gt;headless&lt;/code&gt;模式，在服务端访问前端，然后以PDF格式打印网页。&lt;br&gt;前端大神安利了&lt;code&gt;puppeteer&lt;/code&gt;，确实很不错，还支持定制页眉页脚。&lt;br&gt;再者服务端程序是使用&lt;code&gt;docker&lt;/code&gt;管理的，所以需要创建含有&lt;code&gt;puppeteer&lt;/code&gt;的&lt;code&gt;docker&lt;/code&gt;镜像。&lt;/p&gt;
&lt;h2 id=&quot;先看Dockerfile&quot;&gt;&lt;a href=&quot;#先看Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;先看Dockerfile&quot;&gt;&lt;/a&gt;先看Dockerfile&lt;/h2&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 基于`alpine`版本的`node`10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; node:&lt;span class=&quot;number&quot;&gt;10.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 安装 Chromium (72)。从 alpine/v3.9 版本库中下载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; apk update &amp;amp;&amp;amp; apk upgrade &amp;amp;&amp;amp; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; @v3.9 http://dl-cdn.alpinelinux.org/alpine/v3.9/community &amp;gt;&amp;gt; /etc/apk/repositories &amp;amp;&amp;amp; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; @v3.9 http://dl-cdn.alpinelinux.org/alpine/v3.9/main &amp;gt;&amp;gt; /etc/apk/repositories &amp;amp;&amp;amp; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    apk add --no-cache \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;      freetype@v3.9 \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;      chromium@v3.9 \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;      harfbuzz@v3.9 \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;      nss@v3.9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 安装 Puppeteer 时不让它自动下载 Chromium&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt; PUPPETEER_SKIP_CHROMIUM_DOWNLOAD true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 选择 Chromium 72 对应的 Puppeteer 版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; yarn add puppeteer@1.11.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; addgroup -S pptruser &amp;amp;&amp;amp; adduser -S -g pptruser pptruser \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    &amp;amp;&amp;amp; mkdir -p /home/pptruser/Downloads \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    &amp;amp;&amp;amp; chown -R pptruser:pptruser /home/pptruser&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加 cjk 字体以支持中文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; NotoSansCJK-Regular.ttc  /usr/share/fonts/TTF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;USER&lt;/span&gt; pptruser&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="服务端" scheme="https://liumengjun.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="puppeteer" scheme="https://liumengjun.github.io/tags/puppeteer/"/>
    
      <category term="node" scheme="https://liumengjun.github.io/tags/node/"/>
    
      <category term="docker" scheme="https://liumengjun.github.io/tags/docker/"/>
    
      <category term="headless" scheme="https://liumengjun.github.io/tags/headless/"/>
    
  </entry>
  
  <entry>
    <title>git stash clear 后恢复代码</title>
    <link href="https://liumengjun.github.io/2019/01/15/recover-after-git-stash-clear.html"/>
    <id>https://liumengjun.github.io/2019/01/15/recover-after-git-stash-clear.html</id>
    <published>2019-01-15T13:32:21.000Z</published>
    <updated>2019-04-02T14:20:46.932Z</updated>
    
    <content type="html"><![CDATA[<!-- # git stash clear 后，找回 stash 的代码 --><p>使用<code>git stash</code>隐藏工作区内修改但未提交的代码，<code>git stash list</code>查看<code>stash</code>的历史记录，<code>git stash clear</code>清除所有的stash栈。</p><p>有时候可能不小心<code>git stash clear</code>掉了所有的记录，可是那些代码还有用。哎呀，杯具了，白写了！其实不用慌，可用下面的方法找回：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck --no-reflogs 2&gt;&amp;1 | awk <span class="string">'/dangling commit/ &#123;print $3&#125;'</span> | xargs git show --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>上述命令得到了所有dangling commit，其描述，以及修改的文件列表。观察一下，<code>stash</code>记录描述以<code>WIP</code>开头（work in progress缩写，进行中的工作），结合修改文件列表就能找到那个commit了。</p><p>然后执行<code>git cherry-pick</code>或者<code>git stash apply</code>命令就可以恢复了，参数是那个commit id。</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析</strong>：</h4><ul><li><code>git fsck</code>找出所有dangling的对象，也可以不加<code>--no-reflogs</code>参数。<code>2&gt;&amp;1</code>为了隐藏烦人的错误输出，可不加。  </li><li><code>awk</code>过滤commit类型，并输出commit id值  </li><li><code>xargs git show --stat</code>对所有commit_id执行<code>git show --stat</code>命令  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- # git stash clear 后，找回 stash 的代码 --&gt;
&lt;p&gt;使用&lt;code&gt;git stash&lt;/code&gt;隐藏工作区内修改但未提交的代码，&lt;code&gt;git stash list&lt;/code&gt;查看&lt;code&gt;stash&lt;/code&gt;的历史记录，&lt;code&gt;git stash clear&lt;/code&gt;清除所有的stash栈。&lt;/p&gt;
&lt;p&gt;有时候可能不小心&lt;code&gt;git stash clear&lt;/code&gt;掉了所有的记录，可是那些代码还有用。哎呀，杯具了，白写了！其实不用慌，可用下面的方法找回：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git fsck --no-reflogs 2&amp;gt;&amp;amp;1 | awk &lt;span class=&quot;string&quot;&gt;&#39;/dangling commit/ &amp;#123;print $3&amp;#125;&#39;&lt;/span&gt; | xargs git show --&lt;span class=&quot;built_in&quot;&gt;stat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="代码管理" scheme="https://liumengjun.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://liumengjun.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud zone, 类似 dubbo group 功能</title>
    <link href="https://liumengjun.github.io/2018/12/21/spring-cloud-zone-usage.html"/>
    <id>https://liumengjun.github.io/2018/12/21/spring-cloud-zone-usage.html</id>
    <published>2018-12-21T12:58:35.000Z</published>
    <updated>2019-04-02T15:16:51.412Z</updated>
    
    <content type="html"><![CDATA[<p>spring-cloud zone 本地开发使用</p><p>当我们使用spring-cloud微服务框架时(netflix eureka组合)，有很多微服务程序。开发时，本地启动eureka并注册所有微服务，成本太高。<br>直接使用公共开发环境的eureka，确实省事。比如有A, B, C三个服务，A没有变化，B有修改，C有修改并调用B，此时本地不用启动A，只启动B和C就可以。<br>不过不注意又有个问题，C调用B时，有时候调用公共环境上B服务，甚至其他开发者启动的B服务。dubbo有group配置给服务分组解决此问题；对于spring-cloud，此时需要配置zone:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.instance.metadataMap.zone:</span> <span class="string">YOUR-NAME</span></span><br><span class="line"><span class="string">eureka.client.preferSameZoneEureka:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>本地各个服务都配置zone且相同，各个开发者的zone不同，公共环境默认是defaultZone。然后，C调用B时，就不再混乱了，只调用本地的。(A服务则访问其他zone的)</p><p>刚接触spring-cloud时，不知道怎么解决这个问题，baidu或google搜spring-cloud中group功能也没有好答案。自己动手吧，写了个client继承<code>LoadBalancerFeignClient</code>，用<code>@Configuration</code>机制配置了下，忙活半天多，可以了。转念一想，不对啊，这个功能spring-cloud应该有啊，看看文档去吧。果不其然，确实有。<strong>犯了个错误：不看文档就瞎弄。</strong>使用xxx库或工具时，先看看xxx的官方文档，很有用！</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#_zones" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#_zones</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spring-cloud zone 本地开发使用&lt;/p&gt;
&lt;p&gt;当我们使用spring-cloud微服务框架时(netflix eureka组合)，有很多微服务程序。开发时，本地启动eureka并注册所有微服务，成本太高。&lt;br&gt;直接使用公共开发环境的eureka，确实省事。比如有A, B, C三个服务，A没有变化，B有修改，C有修改并调用B，此时本地不用启动A，只启动B和C就可以。&lt;br&gt;不过不注意又有个问题，C调用B时，有时候调用公共环境上B服务，甚至其他开发者启动的B服务。dubbo有group配置给服务分组解决此问题；对于spring-cloud，此时需要配置zone:&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;eureka.instance.metadataMap.zone:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YOUR-NAME&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;eureka.client.preferSameZoneEureka:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="框架" scheme="https://liumengjun.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
      <category term="spring-cloud" scheme="https://liumengjun.github.io/tags/spring-cloud/"/>
    
      <category term="spring" scheme="https://liumengjun.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>git clone/checkout 指定文件/目录</title>
    <link href="https://liumengjun.github.io/2018/09/24/git-sparse-checkout.html"/>
    <id>https://liumengjun.github.io/2018/09/24/git-sparse-checkout.html</id>
    <published>2018-09-24T15:31:17.000Z</published>
    <updated>2019-04-02T14:20:11.050Z</updated>
    
    <content type="html"><![CDATA[<!-- # git clone/checkout 克隆或下载仓库中指定文件/文件夹(目录) --><p>对比svn，svn可以更新或下载特定目录(甚至精确控制每个目录权限)，可是git不可以吗？在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout（直译为：稀疏检出）模式，这使得Check Out指定文件或者目录成为可能。操作如下：</p><h3 id="对于已有项目"><a href="#对于已有项目" class="headerlink" title="对于已有项目"></a>对于已有项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使能Sparse Checkout(稀疏检出)</span></span><br><span class="line">git config core.sparsecheckout <span class="literal">true</span></span><br><span class="line"><span class="comment"># 编辑'.git/info/sparse-checkout'，规则类似gitignore。比如</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">/src</span></span><br><span class="line"><span class="string">readme.md</span></span><br><span class="line"><span class="string">'</span> &gt; .git/info/sparse-checkout</span><br><span class="line"><span class="comment"># 只保留根目录下/src目录和readme.md文件</span></span><br><span class="line">git checkout</span><br><span class="line"><span class="comment"># ls，就可以看到内容已经变了，只有src和readme.md两项</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="对于新项目"><a href="#对于新项目" class="headerlink" title="对于新项目"></a>对于新项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init newdir &amp;&amp; <span class="built_in">cd</span> newdir</span><br><span class="line"><span class="comment"># 使能Sparse Checkout(稀疏检出)</span></span><br><span class="line">git config core.sparsecheckout <span class="literal">true</span></span><br><span class="line"><span class="comment"># 编辑'.git/info/sparse-checkout'，具体略</span></span><br><span class="line">git remote add origin git@github.com:yourname/yourrepo.git</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- # git clone/checkout 克隆或下载仓库中指定文件/文件夹(目录) --&gt;
&lt;p&gt;对比svn，svn可以更新或下载特定目录(甚至精确控制每个目录权限)，可是git不可以吗？在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout（直译为：稀疏检出）模式，这使得Check Out指定文件或者目录成为可能。操作如下：&lt;/p&gt;
&lt;h3 id=&quot;对于已有项目&quot;&gt;&lt;a href=&quot;#对于已有项目&quot; class=&quot;headerlink&quot; title=&quot;对于已有项目&quot;&gt;&lt;/a&gt;对于已有项目&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使能Sparse Checkout(稀疏检出)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config core.sparsecheckout &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 编辑&#39;.git/info/sparse-checkout&#39;，规则类似gitignore。比如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;/src&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;readme.md&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&lt;/span&gt; &amp;gt; .git/info/sparse-checkout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 只保留根目录下/src目录和readme.md文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ls，就可以看到内容已经变了，只有src和readme.md两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="代码管理" scheme="https://liumengjun.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://liumengjun.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Gradle 跨模块依赖测试代码</title>
    <link href="https://liumengjun.github.io/2018/03/31/gradle-test-source-dependencies.html"/>
    <id>https://liumengjun.github.io/2018/03/31/gradle-test-source-dependencies.html</id>
    <published>2018-03-31T15:00:00.000Z</published>
    <updated>2019-04-02T14:17:32.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gradle中，模块A依赖core模块的测试代码"><a href="#gradle中，模块A依赖core模块的测试代码" class="headerlink" title="gradle中，模块A依赖core模块的测试代码"></a>gradle中，模块A依赖core模块的测试代码</h3><p>测试代码(test文件夹下的代码)，是不跟随打包发布的，而且默认不随project依赖传递到其他的模块，需要用<code>.sourceSets.test.output</code>指明</p><h4 id="简单配置，如下："><a href="#简单配置，如下：" class="headerlink" title="简单配置，如下："></a>简单配置，如下：</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A's build.gradle</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':core'</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    testCompile <span class="keyword">project</span>(<span class="string">':core'</span>).<span class="keyword">sourceSets</span>.test.output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="或者，configuration-of-testOutput"><a href="#或者，configuration-of-testOutput" class="headerlink" title="或者，configuration of testOutput"></a>或者，configuration of testOutput</h4><p>以上只是简单的配置，也可以配置一个testOutput configuration，具体如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core's build.gradle</span></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    testOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    testOutput <span class="keyword">sourceSets</span>.test.output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A's build.gradle</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    testCompile <span class="keyword">project</span>(path: <span class="string">':core'</span>, configuration: <span class="string">'testOutput'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://softnoise.wordpress.com/2014/09/07/gradle-sub-project-test-dependencies-in-multi-project-builds/" target="_blank" rel="noopener">Gradle: sub-project test dependencies in multi-project builds</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;gradle中，模块A依赖core模块的测试代码&quot;&gt;&lt;a href=&quot;#gradle中，模块A依赖core模块的测试代码&quot; class=&quot;headerlink&quot; title=&quot;gradle中，模块A依赖core模块的测试代码&quot;&gt;&lt;/a&gt;gradle中，模块A依赖core模块的测试代码&lt;/h3&gt;&lt;p&gt;测试代码(test文件夹下的代码)，是不跟随打包发布的，而且默认不随project依赖传递到其他的模块，需要用&lt;code&gt;.sourceSets.test.output&lt;/code&gt;指明&lt;/p&gt;
&lt;h4 id=&quot;简单配置，如下：&quot;&gt;&lt;a href=&quot;#简单配置，如下：&quot; class=&quot;headerlink&quot; title=&quot;简单配置，如下：&quot;&gt;&lt;/a&gt;简单配置，如下：&lt;/h4&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// A&#39;s build.gradle&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;dependencies&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;compile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;project&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;:core&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testCompile &lt;span class=&quot;keyword&quot;&gt;project&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;:core&#39;&lt;/span&gt;).&lt;span class=&quot;keyword&quot;&gt;sourceSets&lt;/span&gt;.test.output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="构建工具" scheme="https://liumengjun.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Gradle" scheme="https://liumengjun.github.io/tags/Gradle/"/>
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>关于 Gradle 执行 main-class</title>
    <link href="https://liumengjun.github.io/2018/03/30/gradle-execute-main-class.html"/>
    <id>https://liumengjun.github.io/2018/03/30/gradle-execute-main-class.html</id>
    <published>2018-03-30T13:04:04.000Z</published>
    <updated>2019-04-02T14:18:53.003Z</updated>
    
    <content type="html"><![CDATA[<!-- ### 关于gradle执行main-class --><p><code>用application插件，或使用JavaExec任务</code></p><h4 id="传递jvm-option用jvmArgs属性，示例如下："><a href="#传递jvm-option用jvmArgs属性，示例如下：" class="headerlink" title="传递jvm option用jvmArgs属性，示例如下："></a>传递jvm option用<code>jvmArgs</code>属性，示例如下：</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> execute(type:JavaExec) &#123;</span><br><span class="line">    <span class="comment">//only for projects do not have "main" classes but use default starters</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">project</span>.hasProperty(<span class="string">'mainClassName'</span>)) &#123;</span><br><span class="line">        main = mainClassName</span><br><span class="line">        <span class="keyword">classpath</span> = <span class="keyword">sourceSets</span>.main.runtimeClasspath</span><br><span class="line">        jvmArgs = [<span class="string">"-agentlib:jdwp=transport=dt_socket,address=31843,suspend=n,server=y"</span>, <span class="string">"-Dgreeting=hello"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="调试gradle启动的程序："><a href="#调试gradle启动的程序：" class="headerlink" title="调试gradle启动的程序："></a>调试gradle启动的程序：</h4><p><code>GRADLE_OPTS</code>环境变量只是把给定的参数传递给<code>gradle</code>，没有传递给要执行的<code>main-class</code>。比如要调试程序，用<code>GRADLE_OPTS</code>是没用的，我们不调试<code>gradle</code>，我们需要调试的是<code>main-class</code>，故需要用<code>jvmArgs</code>。</p><h4 id="两个参考链接"><a href="#两个参考链接" class="headerlink" title="两个参考链接"></a>两个参考链接</h4><ul><li><p>(1) <a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="_blank" rel="noopener">The Application Plugin - Gradle User Manual</a></p></li><li><p>(2) <a href="https://stackoverflow.com/questions/21358466/gradle-to-execute-java-class-without-modifying-build-gradle" target="_blank" rel="noopener">Gradle to execute Java class (without modifying build.gradle) - Stack Overflow</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- ### 关于gradle执行main-class --&gt;
&lt;p&gt;&lt;code&gt;用application插件，或使用JavaExec任务&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;传递jvm-option用jvmArgs属性，示例如下：&quot;&gt;&lt;a href=&quot;#传递jvm-option用jvmArgs属性，示例如下：&quot; class=&quot;headerlink&quot; title=&quot;传递jvm option用jvmArgs属性，示例如下：&quot;&gt;&lt;/a&gt;传递jvm option用&lt;code&gt;jvmArgs&lt;/code&gt;属性，示例如下：&lt;/h4&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt; execute(type:JavaExec) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//only for projects do not have &quot;main&quot; classes but use default starters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;project&lt;/span&gt;.hasProperty(&lt;span class=&quot;string&quot;&gt;&#39;mainClassName&#39;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        main = mainClassName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;classpath&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;sourceSets&lt;/span&gt;.main.runtimeClasspath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jvmArgs = [&lt;span class=&quot;string&quot;&gt;&quot;-agentlib:jdwp=transport=dt_socket,address=31843,suspend=n,server=y&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;-Dgreeting=hello&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="构建工具" scheme="https://liumengjun.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Gradle" scheme="https://liumengjun.github.io/tags/Gradle/"/>
    
      <category term="java" scheme="https://liumengjun.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>标记语言文本学习</title>
    <link href="https://liumengjun.github.io/2016/12/19/markup-text.html"/>
    <id>https://liumengjun.github.io/2016/12/19/markup-text.html</id>
    <published>2016-12-19T12:27:10.000Z</published>
    <updated>2016-12-20T15:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;现在最流行的标记语言文本要数<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>(*.md)了，其实它的出现是为了更方便的读写，然后转换为我们更熟知的<a href="http://www.w3.org/TR/html40/" target="_blank" rel="noopener">HTML</a> (<em>HyperText Markup Language</em>)。<code>HTML</code>就是一种标记语言，<a href="http://opendocument.xml.org/" target="_blank" rel="noopener">XML</a> (<em>eXtensible Markup Language</em>)也是，它们都是Mark<strong><code>UP</code></strong>(标记上)，而<code>Markdown</code>是Mark<strong><code>DOWN</code></strong>(标记下)。<br>&nbsp;&nbsp;为了便于读写、或者数据交换，人类已经造出了很多标记语言文本，简单学习几个，具体语法使用某度和某哥会给出来一堆；<code>HTML</code>和<code>XML</code>就不说了。    </p><h2 id="Markdown-md"><a href="#Markdown-md" class="headerlink" title="Markdown(*.md)"></a><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown(*.md)</a></h2><p>&nbsp;&nbsp;应用于代码库的<code>Readme.md</code>文件，帮助文档等等各种场景。<br><code>Markdown</code>很简洁，特别易于读写，可以称得上是最轻量级的了。但是语法有些不统一，尤其各家工具处理缩进和换行时不一样。<br>优点明显大于缺点，大家都在向<a href="https://help.github.com/articles/github-flavored-markdown" target="_blank" rel="noopener">GitHub GFM</a>看齐吧。    </p><a id="more"></a><h2 id="reStructuredText-rst"><a href="#reStructuredText-rst" class="headerlink" title="reStructuredText(*.rst)"></a><a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText(*.rst)</a></h2><p>&nbsp;&nbsp;<a href="http://www.python.org" target="_blank" rel="noopener">Python</a>文档使用较多，写个<code>Readme.rst</code>也是没问题的，<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>也可以直接渲染<code>rst</code>成<code>HTML</code>预览。<br><code>rst</code>语法很规范，对比<code>Markdown</code>有些语法相似，稍微复杂一点点。<a href="http://pypi.python.org/" target="_blank" rel="noopener">Python Package</a>的标准文档格式，起初还创建了一个工具<a href="http://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>来处理<code>Python</code>文档。<br>其实使用<code>rst</code>的也是大有人在。    </p><h2 id="RubyDoc-rdoc"><a href="#RubyDoc-rdoc" class="headerlink" title="RubyDoc(*.rdoc)"></a><a href="https://rdoc.github.io/rdoc/" target="_blank" rel="noopener">RubyDoc(*.rdoc)</a></h2><p>&nbsp;&nbsp;<a href="http://www.ruby-lang.org/" target="_blank" rel="noopener">Ruby</a>项目的文档系统。<code>*.rdoc</code>也被各个代码托管平台直接像<code>HTML</code>那样展示。<br><code>RDoc</code>可以生成<code>HTML</code>，<code>Ruby</code>自带<code>rdoc</code>命令，而且可以像<code>javadoc</code>那样，生成整个项目的在线API文档。<br>不过国人用Ruby的是不是少呀？    </p><h2 id="RedCloth-textile"><a href="#RedCloth-textile" class="headerlink" title="RedCloth(*.textile)"></a><a href="http://redcloth.org/textile" target="_blank" rel="noopener">RedCloth(*.textile)</a></h2><p>&nbsp;&nbsp;<code>textile</code>也是<code>Ruby</code>系的标记语言文本。由<a href="https://github.com/jgarber/redcloth" target="_blank" rel="noopener">RedCloth</a>模块处理。<br>它的语法同样很简洁，在各个平台上<code>*.textile</code>也可以直接以<code>HTML</code>预览。现在<code>textile</code>也被应用到了其他编程语言项目。<br>不过这后缀名太长了。    </p><h2 id="YAML-yml"><a href="#YAML-yml" class="headerlink" title="YAML(*.yml)"></a><a href="http://www.yaml.org/" target="_blank" rel="noopener">YAML(*.yml)</a></h2><p>&nbsp;&nbsp;<code>YAML</code>(<em>YAML Ain’t Markup Language</em>)<code>YAML</code>不是标记语言，但是它以ML结尾所以列出来了学习一下。<br><code>YAML</code>生下来是作为一种所有编程语言友好的数据序列化标准的，也用于项目配置文件，如<a href="http://docs.docker.com/compose/overview/" target="_blank" rel="noopener">docker</a>，<a href="http://swagger.io/swagger-editor/" target="_blank" rel="noopener">swagger</a>，<a href="http://hexo.io/docs/configuration.html" target="_blank" rel="noopener">hexo</a>。<br>顺便提一下<a href="http://json.org/" target="_blank" rel="noopener"><strong>JSON</strong></a>，<code>JSON</code>也用于数据序列化和配置文件。语法格式上<code>YAML</code>取决于代码块缩进，而<code>JSON</code>由’{‘,’}’来区分。    </p><hr><p>&nbsp;&nbsp;平时编程常用的就是上面这几个(虽然YAML不算，但也很常用)，还有其他的如<code>SGML</code>，<code>VRML</code>，<code>WML</code>，<code>DocBook</code>，<code>LaTeX</code>，<code>OPML</code>等等太多了。有些或已过时，有些正在制定标准，各种场景又有不同格式的标记文本…    </p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="http://pandao.github.io/editor.md/" target="_blank" rel="noopener"><code>Editor.md</code></a>: Markdown在线编辑器<br><a href="http://www.pandoc.org/" target="_blank" rel="noopener"><code>Pandoc</code></a>: 支持多种格式互转<br><a href="http://docutils.sourceforge.net/" target="_blank" rel="noopener"><code>docutils</code></a>: 把<code>reStructuredText</code>转换成其他格式<br><a href="http://redcloth.org/" target="_blank" rel="noopener"><code>RedCloth</code></a>: 把textile转成html<br><code>Chrome</code>、<code>Atom</code>、<code>Idea</code>、<code>Sublime</code>都有相应的插件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;现在最流行的标记语言文本要数&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt;(*.md)了，其实它的出现是为了更方便的读写，然后转换为我们更熟知的&lt;a href=&quot;http://www.w3.org/TR/html40/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTML&lt;/a&gt; (&lt;em&gt;HyperText Markup Language&lt;/em&gt;)。&lt;code&gt;HTML&lt;/code&gt;就是一种标记语言，&lt;a href=&quot;http://opendocument.xml.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XML&lt;/a&gt; (&lt;em&gt;eXtensible Markup Language&lt;/em&gt;)也是，它们都是Mark&lt;strong&gt;&lt;code&gt;UP&lt;/code&gt;&lt;/strong&gt;(标记上)，而&lt;code&gt;Markdown&lt;/code&gt;是Mark&lt;strong&gt;&lt;code&gt;DOWN&lt;/code&gt;&lt;/strong&gt;(标记下)。&lt;br&gt;&amp;nbsp;&amp;nbsp;为了便于读写、或者数据交换，人类已经造出了很多标记语言文本，简单学习几个，具体语法使用某度和某哥会给出来一堆；&lt;code&gt;HTML&lt;/code&gt;和&lt;code&gt;XML&lt;/code&gt;就不说了。    &lt;/p&gt;
&lt;h2 id=&quot;Markdown-md&quot;&gt;&lt;a href=&quot;#Markdown-md&quot; class=&quot;headerlink&quot; title=&quot;Markdown(*.md)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown(*.md)&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;应用于代码库的&lt;code&gt;Readme.md&lt;/code&gt;文件，帮助文档等等各种场景。&lt;br&gt;&lt;code&gt;Markdown&lt;/code&gt;很简洁，特别易于读写，可以称得上是最轻量级的了。但是语法有些不统一，尤其各家工具处理缩进和换行时不一样。&lt;br&gt;优点明显大于缺点，大家都在向&lt;a href=&quot;https://help.github.com/articles/github-flavored-markdown&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub GFM&lt;/a&gt;看齐吧。    &lt;/p&gt;
    
    </summary>
    
      <category term="开源工具" scheme="https://liumengjun.github.io/categories/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://liumengjun.github.io/tags/Markdown/"/>
    
      <category term="reStructuredText" scheme="https://liumengjun.github.io/tags/reStructuredText/"/>
    
      <category term="RDoc" scheme="https://liumengjun.github.io/tags/RDoc/"/>
    
      <category term="textile" scheme="https://liumengjun.github.io/tags/textile/"/>
    
      <category term="YAML" scheme="https://liumengjun.github.io/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://liumengjun.github.io/2016/12/15/hello-hexo.html"/>
    <id>https://liumengjun.github.io/2016/12/15/hello-hexo.html</id>
    <published>2016-12-15T12:46:25.000Z</published>
    <updated>2016-12-20T15:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>计划搭建个人博客，用了下面提到的框架，这是自动生成的文章 (尊重原创，没有删除，不是广告哟)</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计划搭建个人博客，用了下面提到的框架，这是自动生成的文章 (尊重原创，没有删除，不是广告哟)&lt;/p&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="网页搭建" scheme="https://liumengjun.github.io/categories/%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Blog" scheme="https://liumengjun.github.io/tags/Blog/"/>
    
      <category term="WEB" scheme="https://liumengjun.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>一些github使用技巧</title>
    <link href="https://liumengjun.github.io/2016/11/15/tricks-gh.html"/>
    <id>https://liumengjun.github.io/2016/11/15/tricks-gh.html</id>
    <published>2016-11-15T12:46:25.000Z</published>
    <updated>2017-01-11T15:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览html"><a href="#预览html" class="headerlink" title="预览html"></a>预览html</h3><ul><li><a href="https://htmlpreview.github.io/" target="_blank" rel="noopener">https://htmlpreview.github.io/</a></li></ul><h3 id="raw文件"><a href="#raw文件" class="headerlink" title="raw文件"></a>raw文件</h3><ul><li>raw.githubusercontent.com<br>e.g. <a href="https://raw.githubusercontent.com/liumengjun/towersOfHanoi/master/towersOfHanoi.apk" target="_blank" rel="noopener">https://raw.githubusercontent.com/liumengjun/towersOfHanoi/master/towersOfHanoi.apk</a></li></ul><a id="more"></a><ul><li>?raw=true<br>e.g. <a href="https://github.com/liumengjun/SudokuPuzzle/blob/master/SudokuPuzzle.apk?raw=true" target="_blank" rel="noopener">https://github.com/liumengjun/SudokuPuzzle/blob/master/SudokuPuzzle.apk?raw=true</a></li></ul><h3 id="打包下载"><a href="#打包下载" class="headerlink" title="打包下载"></a>打包下载</h3><p>归档链接 <code>github.com/repos/:owner/:repo/:archive_format/:ref</code> <a href="https://developer.github.com/v3/repos/contents/#get-archive-link" target="_blank" rel="noopener">@see GitHub API</a></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>owner</code></td><td>GitHub用户名</td></tr><tr><td><code>repo</code></td><td>项目名</td></tr><tr><td><code>archive_format</code></td><td>tarball 或 zipball</td></tr><tr><td><code>ref</code></td><td>有效的Git引用，branch、tag、commit</td></tr></tbody></table><p>例如：<br><a href="https://github.com/liumengjun/liumengjun.github.io/tarball/master" target="_blank" rel="noopener">https://github.com/liumengjun/liumengjun.github.io/tarball/master</a><br><a href="https://github.com/liumengjun/liumengjun.github.io/zipball/b16ffbcb8" target="_blank" rel="noopener">https://github.com/liumengjun/liumengjun.github.io/zipball/b16ffbcb8</a>    </p><h3 id="删除敏感数据"><a href="#删除敏感数据" class="headerlink" title="删除敏感数据"></a>删除敏感数据</h3><ul><li>use <a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">bfg</a> or <a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">git-filter-branch</a>. <a href="https://help.github.com/articles/remove-sensitive-data/" target="_blank" rel="noopener">@see help doc</a></li><li>git-rebase -i 修改历史commit点然后提交（commit较多时不方便）</li></ul><h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><ul><li>create a repo named ${your_username}.github.io. <a href="https://pages.github.com/" target="_blank" rel="noopener">more&gt;&gt;</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;预览html&quot;&gt;&lt;a href=&quot;#预览html&quot; class=&quot;headerlink&quot; title=&quot;预览html&quot;&gt;&lt;/a&gt;预览html&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://htmlpreview.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;raw文件&quot;&gt;&lt;a href=&quot;#raw文件&quot; class=&quot;headerlink&quot; title=&quot;raw文件&quot;&gt;&lt;/a&gt;raw文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;raw.githubusercontent.com&lt;br&gt;e.g. &lt;a href=&quot;https://raw.githubusercontent.com/liumengjun/towersOfHanoi/master/towersOfHanoi.apk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/liumengjun/towersOfHanoi/master/towersOfHanoi.apk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="开源工具" scheme="https://liumengjun.github.io/categories/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://liumengjun.github.io/tags/git/"/>
    
      <category term="github" scheme="https://liumengjun.github.io/tags/github/"/>
    
  </entry>
  
</feed>
