[{"title":"git stash clear 后，找回 stash 的代码","date":"2019-01-15T13:32:21.000Z","path":"2019/01/15/recover-after-git-stash-clear.html","text":"使用git stash隐藏工作区内修改但未提交的代码，git stash list查看stash的历史记录，git stash clear清除所有的stash栈。 有时候可能不小心git stash clear掉了所有的记录，可是那些代码还有用。哎呀，杯具了，白写了！其实不用慌，可用下面的方法找回： 1git fsck --no-reflogs 2&gt;&amp;1 | awk '/dangling commit/ &#123;print $3&#125;' | xargs git show --stat 上述\b命令得到了所有dangling commit，其描述，以及修改的文件列表。观察一下，stash记录描述以WIP开头（work in progress缩写，进行中的工作），结合修改文件列表就能找到那个commit了。 然后执行git cherry-pick或者git stash apply命令就可以恢复了，参数是那个commit id。 解析： git fsck找出\b所有dangling的对象，也可以不加--no-reflogs参数。2&gt;&amp;1为了隐藏烦人的错误输出，可不加。 awk过滤\bcommit类型，并输出commit id值 xargs git show --stat对所有commit_id执行git show --stat命令","categories":[{"name":"代码管理","slug":"代码管理","permalink":"https://liumengjun.github.io/categories/代码管理/"}],"tags":[{"name":"git","slug":"git","permalink":"https://liumengjun.github.io/tags/git/"}]},{"title":"git clone/checkout 克隆或下载仓库中指定文件/文件夹(目录)","date":"2018-09-24T15:31:17.000Z","path":"2018/09/24/git-sparse-checkout.html","text":"对比svn，svn可以更新或下载特定目录(甚至精确控制每个目录权限)，可是git不可以吗？在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout（直译为：稀疏检出）模式，这使得Check Out指定文件或者目录成为可能。操作如下： 对于已有项目12345678910# 使能Sparse Checkout(稀疏检出)git config core.sparsecheckout true# 编辑'.git/info/sparse-checkout'，规则类似gitignore。比如echo '/srcreadme.md' &gt; .git/info/sparse-checkout# 只保留根目录下/src目录和readme.md文件git checkout# ls，就可以看到\b内容已经变了，只有src和readme.md两项 对于新项目1234567git init newdir &amp;&amp; cd newdir# 使能Sparse Checkout(稀疏检出)git config core.sparsecheckout true# 编辑'.git/info/sparse-checkout'，具体略git remote add origin git@github.com:yourname/yourrepo.git# 下载git pull origin master","categories":[{"name":"代码管理","slug":"代码管理","permalink":"https://liumengjun.github.io/categories/代码管理/"}],"tags":[{"name":"git","slug":"git","permalink":"https://liumengjun.github.io/tags/git/"}]},{"title":"Gradle 跨模块依赖测试代码","date":"2018-03-31T15:00:00.000Z","path":"2018/03/31/gradle-test-source-dependencies.html","text":"gradle中，模块\bA依赖core模块的测试代码测试代码(test文件夹下的代码)，是不跟随打包发布的，而且默认不随project依赖传递到\b其他的模块，需要用.sourceSets.test.output指明 简单配置，如下：123456// A's build.gradledependencies &#123; compile project(':core') //... testCompile project(':core').sourceSets.test.output&#125; 或者，configuration of testOutput以上只是简单的配置，也可以配置一个testOutput configuration，具体如下： 1234567// core's build.gradleconfigurations &#123; testOutput&#125;dependencies &#123; testOutput sourceSets.test.output&#125; 然后 12345// A's build.gradledependencies &#123; //... testCompile project(path: ':core', configuration: 'testOutput')&#125; 参考链接 Gradle: sub-project test dependencies in multi-project builds","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://liumengjun.github.io/categories/构建工具/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://liumengjun.github.io/tags/Gradle/"},{"name":"java","slug":"java","permalink":"https://liumengjun.github.io/tags/java/"}]},{"title":"关于 Gradle 执行 main-class","date":"2018-03-30T13:04:04.000Z","path":"2018/03/30/gradle-execute-main-class.html","text":"用application插件，或使用JavaExec任务 传递jvm option用jvmArgs属性，示例如下：12345678task execute(type:JavaExec) &#123; //only for projects do not have \"main\" classes but use default starters if(project.hasProperty('mainClassName')) &#123; main = mainClassName classpath = sourceSets.main.runtimeClasspath jvmArgs = [\"-agentlib:jdwp=transport=dt_socket,address=31843,suspend=n,server=y\", \"-Dgreeting=hello\"] &#125;&#125; 调试gradle启动的程序：GRADLE_OPTS环境变量只是把给定的参数传递给gradle，没有传递给要执行的main-class。比如要调试程序，用GRADLE_OPTS是没用的，我们不调试gradle，我们需要调试的是main-class，故需要用jvmArgs。 两个参考链接 (1) The Application Plugin - Gradle User Manual (2) Gradle to execute Java class (without modifying build.gradle) - Stack Overflow","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://liumengjun.github.io/categories/构建工具/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://liumengjun.github.io/tags/Gradle/"},{"name":"java","slug":"java","permalink":"https://liumengjun.github.io/tags/java/"}]},{"title":"标记语言文本学习","date":"2016-12-19T12:27:10.000Z","path":"2016/12/19/markup-text.html","text":"&nbsp;&nbsp;现在最流行的标记语言文本要数Markdown(*.md)了，其实它的出现是为了更方便的读写，然后转换为我们更熟知的HTML (HyperText Markup Language)。HTML就是一种标记语言，XML (eXtensible Markup Language)也是，它们都是MarkUP(标记上)，而Markdown是MarkDOWN(标记下)。&nbsp;&nbsp;为了便于读写、或者数据交换，人类已经造出了很多标记语言文本，简单学习几个，具体语法使用某度和某哥会给出来一堆；HTML和XML就不说了。 Markdown(*.md)&nbsp;&nbsp;应用于代码库的Readme.md文件，帮助文档等等各种场景。Markdown很简洁，特别易于读写，可以称得上是最轻量级的了。但是语法有些不统一，尤其各家工具处理缩进和换行时不一样。优点明显大于缺点，大家都在向GitHub GFM看齐吧。 reStructuredText(*.rst)&nbsp;&nbsp;Python文档使用较多，写个Readme.rst也是没问题的，GitHub也可以直接渲染rst成HTML预览。rst语法很规范，对比Markdown有些语法相似，稍微复杂一点点。Python Package的标准文档格式，起初还创建了一个工具Sphinx来处理Python文档。其实使用rst的也是大有人在。 RubyDoc(*.rdoc)&nbsp;&nbsp;Ruby项目的文档系统。*.rdoc也被各个代码托管平台直接像HTML那样展示。RDoc可以生成HTML，Ruby自带rdoc命令，而且可以像javadoc那样，生成整个项目的在线API文档。不过国人用Ruby的是不是少呀？ RedCloth(*.textile)&nbsp;&nbsp;textile也是Ruby系的标记语言文本。由RedCloth模块处理。它的语法同样很简洁，在各个平台上*.textile也可以直接以HTML预览。现在textile也被应用到了其他编程语言项目。不过这后缀名太长了。 YAML(*.yml)&nbsp;&nbsp;YAML(YAML Ain’t Markup Language)YAML不是标记语言，但是它以ML结尾所以列出来了学习一下。YAML生下来是作为一种所有编程语言友好的数据序列化标准的，也用于项目配置文件，如docker，swagger，hexo。顺便提一下JSON，JSON也用于数据序列化和配置文件。语法格式上YAML取决于代码块缩进，而JSON由’{‘,’}’来区分。 &nbsp;&nbsp;平时编程常用的就是上面这几个(虽然YAML不算，但也很常用)，还有其他的如SGML，VRML，WML，DocBook，LaTeX，OPML等等太多了。有些或已过时，有些正在制定标准，各种场景又有不同格式的标记文本… 工具Editor.md: Markdown在线编辑器Pandoc: 支持多种格式互转docutils: 把reStructuredText转换成其他格式RedCloth: 把textile转成htmlChrome、Atom、Idea、Sublime都有相应的插件。","categories":[{"name":"开源工具","slug":"开源工具","permalink":"https://liumengjun.github.io/categories/开源工具/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://liumengjun.github.io/tags/Markdown/"},{"name":"reStructuredText","slug":"reStructuredText","permalink":"https://liumengjun.github.io/tags/reStructuredText/"},{"name":"RDoc","slug":"RDoc","permalink":"https://liumengjun.github.io/tags/RDoc/"},{"name":"textile","slug":"textile","permalink":"https://liumengjun.github.io/tags/textile/"},{"name":"YAML","slug":"YAML","permalink":"https://liumengjun.github.io/tags/YAML/"}]},{"title":"Hello Hexo","date":"2016-12-15T12:46:25.000Z","path":"2016/12/15/hello-hexo.html","text":"计划搭建个人博客，用了下面提到的框架，这是自动生成的文章 (尊重原创，没有删除，不是广告哟) Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"网页搭建","slug":"网页搭建","permalink":"https://liumengjun.github.io/categories/网页搭建/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://liumengjun.github.io/tags/Blog/"},{"name":"WEB","slug":"WEB","permalink":"https://liumengjun.github.io/tags/WEB/"}]},{"title":"一些github使用技巧","date":"2016-11-15T12:46:25.000Z","path":"2016/11/15/tricks-gh.html","text":"预览html https://htmlpreview.github.io/ raw文件 raw.githubusercontent.come.g. https://raw.githubusercontent.com/liumengjun/towersOfHanoi/master/towersOfHanoi.apk ?raw=truee.g. https://github.com/liumengjun/SudokuPuzzle/blob/master/SudokuPuzzle.apk?raw=true 打包下载归档链接 github.com/repos/:owner/:repo/:archive_format/:ref @see GitHub API 字段 说明 owner GitHub用户名 repo 项目名 archive_format tarball 或 zipball ref 有效的Git引用，branch、tag、commit 例如：https://github.com/liumengjun/liumengjun.github.io/tarball/masterhttps://github.com/liumengjun/liumengjun.github.io/zipball/b16ffbcb8 删除敏感数据 use bfg or git-filter-branch. @see help doc git-rebase -i 修改历史commit点然后提交（commit较多时不方便） GitHub Pages create a repo named ${your_username}.github.io. more&gt;&gt;","categories":[{"name":"开源工具","slug":"开源工具","permalink":"https://liumengjun.github.io/categories/开源工具/"}],"tags":[{"name":"github","slug":"github","permalink":"https://liumengjun.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://liumengjun.github.io/tags/git/"}]}]